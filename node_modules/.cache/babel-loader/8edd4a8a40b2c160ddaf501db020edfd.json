{"ast":null,"code":"import { useMemo, useRef } from 'react';\nimport { useSubscription } from 'use-subscription';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { isActorWithState } from './useActor';\nimport { getServiceSnapshot } from './useService';\nfunction isService(actor) {\n  return 'state' in actor && 'machine' in actor;\n}\nvar defaultCompare = function defaultCompare(a, b) {\n  return a === b;\n};\nvar defaultGetSnapshot = function defaultGetSnapshot(a) {\n  return isService(a) ? getServiceSnapshot(a) : isActorWithState(a) ? a.state : undefined;\n};\nexport function useSelector(actor, selector, compare, getSnapshot) {\n  if (compare === void 0) {\n    compare = defaultCompare;\n  }\n  if (getSnapshot === void 0) {\n    getSnapshot = defaultGetSnapshot;\n  }\n  var latestSelectorRef = useRef(selector);\n  var subscription = useMemo(function () {\n    var snapshot = getSnapshot(actor);\n    var current = selector(snapshot);\n    var notifySubscriber;\n    return {\n      getSnapshot: function getSnapshot() {\n        return snapshot;\n      },\n      getCurrentValue: function getCurrentValue() {\n        return current;\n      },\n      setCurrentValue: function setCurrentValue(newCurrent) {\n        current = newCurrent;\n        notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();\n      },\n      subscribe: function subscribe(callback) {\n        notifySubscriber = callback;\n        var sub = actor.subscribe(function (emitted) {\n          snapshot = emitted;\n          var next = latestSelectorRef.current(emitted);\n          if (!compare(current, next)) {\n            current = next;\n            callback();\n          }\n        });\n        return function () {\n          sub.unsubscribe();\n        };\n      }\n    };\n    // intentionally omit `getSnapshot` and `compare`\n    // - `getSnapshot`: it is only supposed to read the \"initial\" snapshot of an actor\n    // - `compare`: is really supposed to be idempotent and the same throughout the lifetime of this hook (the same assumption is made in React Redux v7)\n  }, [actor]);\n  var currentSelected = useSubscription(subscription);\n  var currentChanged = false;\n  if (latestSelectorRef.current !== selector) {\n    var selected = selector(subscription.getSnapshot());\n    if (!compare(currentSelected, selected)) {\n      currentChanged = true;\n      currentSelected = selected;\n    }\n  }\n  useIsomorphicLayoutEffect(function () {\n    latestSelectorRef.current = selector;\n    // this condition should not be required, but setState bailouts are currently buggy: https://github.com/facebook/react/issues/22654\n    if (currentChanged) {\n      // required so we don't cause a rerender by setting state (this could create infinite rerendering loop with inline selectors)\n      // at the same time we need to update the value within the subscription so new emits can compare against what has been returned to the user as current value\n      subscription.setCurrentValue(currentSelected);\n    }\n  });\n  return currentSelected;\n}","map":null,"metadata":{},"sourceType":"module"}