{"ast":null,"code":"import e from \"@reach/portal\";\nimport n, { useRef as r, useDebugValue as t, useEffect as o, useLayoutEffect as i, useState as a, useCallback as c, useMemo as u, useImperativeHandle as s, forwardRef as l } from \"react\";\nimport { useMachine as d } from \"@xstate/react\";\nimport { useSpring as f, interpolate as v, animated as m, config as p } from \"react-spring\";\nimport { useDrag as y, rubberbandIfOutOfBounds as h } from \"react-use-gesture\";\nimport { createFocusTrap as g } from \"focus-trap\";\nimport { disableBodyScroll as S, enableBodyScroll as E } from \"body-scroll-lock\";\nimport { ResizeObserver as P } from \"@juggle/resize-observer\";\nimport { Machine as b, assign as R } from \"xstate\";\nfunction x() {\n  return x = Object.assign || function (e) {\n    for (var n = 1; n < arguments.length; n++) {\n      var r = arguments[n];\n      for (var t in r) Object.prototype.hasOwnProperty.call(r, t) && (e[t] = r[t]);\n    }\n    return e;\n  }, x.apply(this, arguments);\n}\nfunction C(e, n) {\n  if (null == e) return {};\n  var r,\n    t,\n    o = {},\n    i = Object.keys(e);\n  for (t = 0; t < i.length; t++) n.indexOf(r = i[t]) >= 0 || (o[r] = e[r]);\n  return o;\n}\nvar O = \"undefined\" != typeof window ? i : o;\nfunction N(e, n, r) {\n  return n = (n = +n) == n ? n : 0, r = (r = +r) == r ? r : 0, (e = +e) == e && (e = (e = e <= r ? e : r) >= n ? e : n), e;\n}\nfunction w(e) {\n  var n = Math.round(e);\n  if (Number.isNaN(e)) throw new TypeError(\"Found a NaN! Check your snapPoints / defaultSnap / snapTo \");\n  return n;\n}\nvar H = {\n  box: \"border-box\"\n};\nfunction D(e, n) {\n  var r = n.label,\n    o = n.enabled,\n    i = n.resizeSourceRef,\n    u = a(0),\n    s = u[0],\n    l = u[1];\n  t(r + \": \" + s);\n  var d = c(function (e) {\n    l(e[0].borderBoxSize[0].blockSize), i.current = \"element\";\n  }, [i]);\n  return O(function () {\n    if (e.current && o) {\n      var n = new P(d);\n      return n.observe(e.current, H), function () {\n        n.disconnect();\n      };\n    }\n  }, [e, d, o]), o ? s : 0;\n}\nfunction k(e) {\n  return void 0 === e && (e = 1e3), new Promise(function (n) {\n    return setTimeout(n, e);\n  });\n}\nvar z = {\n    DRAG: {\n      target: \"#overlay.dragging\",\n      actions: \"onOpenEnd\"\n    }\n  },\n  j = {\n    RESIZE: {\n      target: \"#overlay.resizing\",\n      actions: \"onOpenEnd\"\n    }\n  },\n  A = b({\n    id: \"overlay\",\n    initial: \"closed\",\n    context: {\n      initialState: \"CLOSED\"\n    },\n    states: {\n      closed: {\n        on: {\n          OPEN: \"opening\",\n          CLOSE: void 0\n        }\n      },\n      opening: {\n        initial: \"start\",\n        states: {\n          start: {\n            invoke: {\n              src: \"onOpenStart\",\n              onDone: \"transition\"\n            }\n          },\n          transition: {\n            always: [{\n              target: \"immediately\",\n              cond: \"initiallyOpen\"\n            }, {\n              target: \"smoothly\",\n              cond: \"initiallyClosed\"\n            }]\n          },\n          immediately: {\n            initial: \"open\",\n            states: {\n              open: {\n                invoke: {\n                  src: \"openImmediately\",\n                  onDone: \"activating\"\n                }\n              },\n              activating: {\n                invoke: {\n                  src: \"activate\",\n                  onDone: \"#overlay.opening.end\"\n                },\n                on: x({}, z, j)\n              }\n            }\n          },\n          smoothly: {\n            initial: \"visuallyHidden\",\n            states: {\n              visuallyHidden: {\n                invoke: {\n                  src: \"renderVisuallyHidden\",\n                  onDone: \"activating\"\n                }\n              },\n              activating: {\n                invoke: {\n                  src: \"activate\",\n                  onDone: \"open\"\n                }\n              },\n              open: {\n                invoke: {\n                  src: \"openSmoothly\",\n                  onDone: \"#overlay.opening.end\"\n                },\n                on: x({}, z, j)\n              }\n            }\n          },\n          end: {\n            invoke: {\n              src: \"onOpenEnd\",\n              onDone: \"done\"\n            },\n            on: {\n              CLOSE: \"#overlay.closing\",\n              DRAG: \"#overlay.dragging\"\n            }\n          },\n          done: {\n            type: \"final\"\n          }\n        },\n        on: x({}, {\n          CLOSE: {\n            target: \"#overlay.closing\",\n            actions: \"onOpenCancel\"\n          }\n        }),\n        onDone: \"open\"\n      },\n      open: {\n        on: {\n          DRAG: \"#overlay.dragging\",\n          SNAP: \"snapping\",\n          RESIZE: \"resizing\"\n        }\n      },\n      dragging: {\n        on: {\n          SNAP: \"snapping\"\n        }\n      },\n      snapping: {\n        initial: \"start\",\n        states: {\n          start: {\n            invoke: {\n              src: \"onSnapStart\",\n              onDone: \"snappingSmoothly\"\n            },\n            entry: [R({\n              y: function y(e, n) {\n                return n.payload.y;\n              },\n              velocity: function velocity(e, n) {\n                return n.payload.velocity;\n              },\n              snapSource: function snapSource(e, n) {\n                var r = n.payload.source;\n                return void 0 === r ? \"custom\" : r;\n              }\n            })]\n          },\n          snappingSmoothly: {\n            invoke: {\n              src: \"snapSmoothly\",\n              onDone: \"end\"\n            }\n          },\n          end: {\n            invoke: {\n              src: \"onSnapEnd\",\n              onDone: \"done\"\n            },\n            on: {\n              RESIZE: \"#overlay.resizing\",\n              SNAP: \"#overlay.snapping\",\n              CLOSE: \"#overlay.closing\",\n              DRAG: \"#overlay.dragging\"\n            }\n          },\n          done: {\n            type: \"final\"\n          }\n        },\n        on: {\n          SNAP: {\n            target: \"snapping\",\n            actions: \"onSnapEnd\"\n          },\n          RESIZE: {\n            target: \"#overlay.resizing\",\n            actions: \"onSnapCancel\"\n          },\n          DRAG: {\n            target: \"#overlay.dragging\",\n            actions: \"onSnapCancel\"\n          },\n          CLOSE: {\n            target: \"#overlay.closing\",\n            actions: \"onSnapCancel\"\n          }\n        },\n        onDone: \"open\"\n      },\n      resizing: {\n        initial: \"start\",\n        states: {\n          start: {\n            invoke: {\n              src: \"onResizeStart\",\n              onDone: \"resizingSmoothly\"\n            }\n          },\n          resizingSmoothly: {\n            invoke: {\n              src: \"resizeSmoothly\",\n              onDone: \"end\"\n            }\n          },\n          end: {\n            invoke: {\n              src: \"onResizeEnd\",\n              onDone: \"done\"\n            },\n            on: {\n              SNAP: \"#overlay.snapping\",\n              CLOSE: \"#overlay.closing\",\n              DRAG: \"#overlay.dragging\"\n            }\n          },\n          done: {\n            type: \"final\"\n          }\n        },\n        on: {\n          RESIZE: {\n            target: \"resizing\",\n            actions: \"onResizeEnd\"\n          },\n          SNAP: {\n            target: \"snapping\",\n            actions: \"onResizeCancel\"\n          },\n          DRAG: {\n            target: \"#overlay.dragging\",\n            actions: \"onResizeCancel\"\n          },\n          CLOSE: {\n            target: \"#overlay.closing\",\n            actions: \"onResizeCancel\"\n          }\n        },\n        onDone: \"open\"\n      },\n      closing: {\n        initial: \"start\",\n        states: {\n          start: {\n            invoke: {\n              src: \"onCloseStart\",\n              onDone: \"deactivating\"\n            },\n            on: {\n              OPEN: {\n                target: \"#overlay.open\",\n                actions: \"onCloseCancel\"\n              }\n            }\n          },\n          deactivating: {\n            invoke: {\n              src: \"deactivate\",\n              onDone: \"closingSmoothly\"\n            }\n          },\n          closingSmoothly: {\n            invoke: {\n              src: \"closeSmoothly\",\n              onDone: \"end\"\n            }\n          },\n          end: {\n            invoke: {\n              src: \"onCloseEnd\",\n              onDone: \"done\"\n            },\n            on: {\n              OPEN: {\n                target: \"#overlay.opening\",\n                actions: \"onCloseCancel\"\n              }\n            }\n          },\n          done: {\n            type: \"final\"\n          }\n        },\n        on: {\n          CLOSE: void 0,\n          OPEN: {\n            target: \"#overlay.opening\",\n            actions: \"onCloseCancel\"\n          }\n        },\n        onDone: \"closed\"\n      }\n    },\n    on: {\n      CLOSE: \"closing\"\n    }\n  }, {\n    actions: {\n      onOpenCancel: function onOpenCancel(e, n) {},\n      onSnapCancel: function onSnapCancel(e, n) {},\n      onResizeCancel: function onResizeCancel(e, n) {},\n      onCloseCancel: function onCloseCancel(e, n) {},\n      onOpenEnd: function onOpenEnd(e, n) {},\n      onSnapEnd: function onSnapEnd(e, n) {},\n      onRezizeEnd: function onRezizeEnd(e, n) {}\n    },\n    services: {\n      onSnapStart: function onSnapStart() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      onOpenStart: function onOpenStart() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      onCloseStart: function onCloseStart() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      onResizeStart: function onResizeStart() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      onSnapEnd: function onSnapEnd() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      onOpenEnd: function onOpenEnd() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      onCloseEnd: function onCloseEnd() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      onResizeEnd: function onResizeEnd() {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      renderVisuallyHidden: function renderVisuallyHidden(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      activate: function activate(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      deactivate: function deactivate(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      openSmoothly: function openSmoothly(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      openImmediately: function openImmediately(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      snapSmoothly: function snapSmoothly(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      resizeSmoothly: function resizeSmoothly(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      },\n      closeSmoothly: function closeSmoothly(e, n) {\n        try {\n          return Promise.resolve(k()).then(function () {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    },\n    guards: {\n      initiallyClosed: function initiallyClosed(e) {\n        return \"CLOSED\" === e.initialState;\n      },\n      initiallyOpen: function initiallyOpen(e) {\n        return \"OPEN\" === e.initialState;\n      }\n    }\n  }),\n  L = [\"children\", \"sibling\", \"className\", \"footer\", \"header\", \"open\", \"initialState\", \"lastSnapRef\", \"initialFocusRef\", \"onDismiss\", \"maxHeight\", \"defaultSnap\", \"snapPoints\", \"blocking\", \"scrollLocking\", \"style\", \"onSpringStart\", \"onSpringCancel\", \"onSpringEnd\", \"reserveScrollBarGap\", \"expandOnContentDrag\"],\n  T = [\"velocity\"],\n  M = [\"onRest\", \"config\"],\n  I = p.default,\n  F = I.tension,\n  G = I.friction,\n  Z = n.forwardRef(function (e, i) {\n    var l = e.children,\n      p = e.sibling,\n      P = e.className,\n      b = e.footer,\n      R = e.header,\n      H = e.open,\n      k = e.initialState,\n      z = e.lastSnapRef,\n      j = e.initialFocusRef,\n      I = e.onDismiss,\n      Z = e.maxHeight,\n      K = e.defaultSnap,\n      J = void 0 === K ? q : K,\n      Q = e.snapPoints,\n      U = void 0 === Q ? V : Q,\n      W = e.blocking,\n      X = void 0 === W || W,\n      Y = e.scrollLocking,\n      $ = void 0 === Y || Y,\n      _ = e.style,\n      ee = e.onSpringStart,\n      ne = e.onSpringCancel,\n      re = e.onSpringEnd,\n      te = e.reserveScrollBarGap,\n      oe = void 0 === te ? X : te,\n      ie = e.expandOnContentDrag,\n      ae = void 0 !== ie && ie,\n      ce = C(e, L),\n      ue = function () {\n        var e = a(!1),\n          n = e[0],\n          r = e[1],\n          t = a({}),\n          i = t[0],\n          u = t[1],\n          s = c(function (e) {\n            return u(function (n) {\n              var r;\n              return x({}, n, ((r = {})[e] = !1, r));\n            }), function () {\n              u(function (n) {\n                var r;\n                return x({}, n, ((r = {})[e] = !0, r));\n              });\n            };\n          }, []);\n        return o(function () {\n          var e = Object.values(i);\n          0 !== e.length && e.every(Boolean) && r(!0);\n        }, [i]), {\n          ready: n,\n          registerReady: s\n        };\n      }(),\n      se = ue.ready,\n      le = ue.registerReady,\n      de = r(!1),\n      fe = r(ee),\n      ve = r(ne),\n      me = r(re);\n    o(function () {\n      fe.current = ee, ve.current = ne, me.current = re;\n    }, [ne, ee, re]);\n    var pe,\n      ye,\n      he = f(function () {\n        return {\n          y: 0,\n          ready: 0,\n          maxHeight: 0,\n          minSnap: 0,\n          maxSnap: 0\n        };\n      }),\n      ge = he[0],\n      Se = he[1],\n      Ee = r(null),\n      Pe = r(null),\n      be = r(null),\n      Re = r(null),\n      xe = r(null),\n      Ce = r(null),\n      Oe = r(0),\n      Ne = r(),\n      we = r(!1),\n      He = (pe = u(function () {\n        return \"undefined\" != typeof window ? window.matchMedia(\"(prefers-reduced-motion: reduce)\") : null;\n      }, []), ye = r(null == pe ? void 0 : pe.matches), t(ye.current ? \"reduce\" : \"no-preference\"), o(function () {\n        var e = function e(_e) {\n          ye.current = _e.matches;\n        };\n        return null == pe || pe.addListener(e), function () {\n          return null == pe ? void 0 : pe.removeListener(e);\n        };\n      }, [pe]), ye),\n      De = function (e) {\n        var n = e.targetRef,\n          i = e.enabled,\n          a = e.reserveScrollBarGap,\n          c = r({\n            activate: function activate() {\n              throw new TypeError(\"Tried to activate scroll lock too early\");\n            },\n            deactivate: function deactivate() {}\n          });\n        return t(i ? \"Enabled\" : \"Disabled\"), o(function () {\n          if (!i) return c.current.deactivate(), void (c.current = {\n            activate: function activate() {},\n            deactivate: function deactivate() {}\n          });\n          var e = n.current,\n            r = !1;\n          c.current = {\n            activate: function activate() {\n              r || (r = !0, S(e, {\n                allowTouchMove: function allowTouchMove(e) {\n                  return e.closest(\"[data-body-scroll-lock-ignore]\");\n                },\n                reserveScrollBarGap: a\n              }));\n            },\n            deactivate: function deactivate() {\n              r && (r = !1, E(e));\n            }\n          };\n        }, [i, n, a]), c;\n      }({\n        targetRef: Pe,\n        enabled: se && $,\n        reserveScrollBarGap: oe\n      }),\n      ke = function (e) {\n        var n = e.targetRef,\n          i = e.enabled,\n          a = r({\n            activate: function activate() {\n              throw new TypeError(\"Tried to activate aria hider too early\");\n            },\n            deactivate: function deactivate() {}\n          });\n        return t(i ? \"Enabled\" : \"Disabled\"), o(function () {\n          if (!i) return a.current.deactivate(), void (a.current = {\n            activate: function activate() {},\n            deactivate: function deactivate() {}\n          });\n          var e = n.current,\n            r = !1,\n            t = [],\n            o = [];\n          a.current = {\n            activate: function activate() {\n              if (!r) {\n                r = !0;\n                var n = e.parentNode;\n                document.querySelectorAll(\"body > *\").forEach(function (e) {\n                  if (e !== n) {\n                    var r = e.getAttribute(\"aria-hidden\");\n                    null !== r && \"false\" !== r || (t.push(r), o.push(e), e.setAttribute(\"aria-hidden\", \"true\"));\n                  }\n                });\n              }\n            },\n            deactivate: function deactivate() {\n              r && (r = !1, o.forEach(function (e, n) {\n                var r = t[n];\n                null === r ? e.removeAttribute(\"aria-hidden\") : e.setAttribute(\"aria-hidden\", r);\n              }), t = [], o = []);\n            }\n          };\n        }, [n, i]), a;\n      }({\n        targetRef: Ee,\n        enabled: se && X\n      }),\n      ze = function (e) {\n        var n = e.targetRef,\n          i = e.fallbackRef,\n          a = e.initialFocusRef,\n          c = e.enabled,\n          u = r({\n            activate: function activate() {\n              throw new TypeError(\"Tried to activate focus trap too early\");\n            },\n            deactivate: function deactivate() {}\n          });\n        return t(c ? \"Enabled\" : \"Disabled\"), o(function () {\n          if (!c) return u.current.deactivate(), void (u.current = {\n            activate: function activate() {},\n            deactivate: function deactivate() {}\n          });\n          var e = i.current,\n            r = g(n.current, {\n              onActivate: void 0,\n              initialFocus: a ? function () {\n                return (null == a ? void 0 : a.current) || e;\n              } : void 0,\n              fallbackFocus: e,\n              escapeDeactivates: !1,\n              clickOutsideDeactivates: !1\n            }),\n            t = !1;\n          u.current = {\n            activate: function activate() {\n              try {\n                return t ? Promise.resolve() : (t = !0, Promise.resolve(r.activate()).then(function () {\n                  return Promise.resolve(new Promise(function (e) {\n                    return setTimeout(function () {\n                      return e(void 0);\n                    }, 0);\n                  })).then(function () {});\n                }));\n              } catch (e) {\n                return Promise.reject(e);\n              }\n            },\n            deactivate: function deactivate() {\n              t && (t = !1, r.deactivate());\n            }\n          };\n        }, [c, i, a, n]), u;\n      }({\n        targetRef: Ee,\n        fallbackRef: Ce,\n        initialFocusRef: j || void 0,\n        enabled: se && X && !1 !== j\n      }),\n      je = function (e) {\n        var n = e.getSnapPoints,\n          i = e.heightRef,\n          c = e.lastSnapRef,\n          s = e.ready,\n          l = function (e) {\n            var n = e.contentRef,\n              i = e.controlledMaxHeight,\n              c = e.footerEnabled,\n              s = e.footerRef,\n              l = e.headerEnabled,\n              d = e.headerRef,\n              f = e.registerReady,\n              v = e.resizeSourceRef,\n              m = u(function () {\n                return f(\"contentHeight\");\n              }, [f]),\n              p = function (e, n, i) {\n                var c = u(function () {\n                    return n(\"maxHeight\");\n                  }, [n]),\n                  s = a(function () {\n                    return w(e) || \"undefined\" != typeof window ? window.innerHeight : 0;\n                  }),\n                  l = s[0],\n                  d = s[1],\n                  f = l > 0,\n                  v = r(0);\n                return t(e ? \"controlled\" : \"auto\"), o(function () {\n                  f && c();\n                }, [f, c]), O(function () {\n                  if (e) return d(w(e)), void (i.current = \"maxheightprop\");\n                  var n = function n() {\n                    v.current || (v.current = requestAnimationFrame(function () {\n                      d(window.innerHeight), i.current = \"window\", v.current = 0;\n                    }));\n                  };\n                  return window.addEventListener(\"resize\", n), d(window.innerHeight), i.current = \"window\", c(), function () {\n                    window.removeEventListener(\"resize\", n), cancelAnimationFrame(v.current);\n                  };\n                }, [e, c, i]), l;\n              }(i, f, v),\n              y = D(d, {\n                label: \"headerHeight\",\n                enabled: l,\n                resizeSourceRef: v\n              }),\n              h = D(n, {\n                label: \"contentHeight\",\n                enabled: !0,\n                resizeSourceRef: v\n              }),\n              g = D(s, {\n                label: \"footerHeight\",\n                enabled: c,\n                resizeSourceRef: v\n              }),\n              S = Math.min(p - y - g, h) + y + g;\n            t(\"minHeight: \" + S);\n            var E = h > 0;\n            return o(function () {\n              E && m();\n            }, [E, m]), {\n              maxHeight: p,\n              minHeight: S,\n              headerHeight: y,\n              footerHeight: g\n            };\n          }({\n            contentRef: e.contentRef,\n            controlledMaxHeight: e.controlledMaxHeight,\n            footerEnabled: e.footerEnabled,\n            footerRef: e.footerRef,\n            headerEnabled: e.headerEnabled,\n            headerRef: e.headerRef,\n            registerReady: e.registerReady,\n            resizeSourceRef: e.resizeSourceRef\n          }),\n          d = l.maxHeight,\n          f = l.minHeight,\n          v = l.headerHeight,\n          m = l.footerHeight,\n          p = function (e, n) {\n            var r = [].concat(e).map(w).reduce(function (e, r) {\n                return e.add(N(r, 0, n)), e;\n              }, new Set()),\n              t = Array.from(r),\n              o = Math.min.apply(Math, t);\n            if (Number.isNaN(o)) throw new TypeError(\"minSnap is NaN\");\n            var i = Math.max.apply(Math, t);\n            if (Number.isNaN(i)) throw new TypeError(\"maxSnap is NaN\");\n            return {\n              snapPoints: t,\n              minSnap: o,\n              maxSnap: i\n            };\n          }(s ? n({\n            height: i.current,\n            footerHeight: m,\n            headerHeight: v,\n            minHeight: f,\n            maxHeight: d\n          }) : [0], d),\n          y = p.snapPoints,\n          h = p.minSnap,\n          g = p.maxSnap;\n        return t(\"minSnap: \" + h + \", maxSnap:\" + g), {\n          minSnap: h,\n          maxSnap: g,\n          findSnap: function findSnap(e) {\n            var n = w(\"function\" == typeof e ? e({\n              footerHeight: m,\n              headerHeight: v,\n              height: i.current,\n              minHeight: f,\n              maxHeight: d,\n              snapPoints: y,\n              lastSnap: c.current\n            }) : e);\n            return y.reduce(function (e, r) {\n              return Math.abs(r - n) < Math.abs(e - n) ? r : e;\n            }, h);\n          },\n          maxHeight: d\n        };\n      }({\n        contentRef: be,\n        controlledMaxHeight: Z,\n        footerEnabled: !!b,\n        footerRef: xe,\n        getSnapPoints: U,\n        headerEnabled: !1 !== R,\n        headerRef: Re,\n        heightRef: Oe,\n        lastSnapRef: z,\n        ready: se,\n        registerReady: le,\n        resizeSourceRef: Ne\n      }),\n      Ae = je.minSnap,\n      Le = je.maxSnap,\n      Te = je.maxHeight,\n      Me = je.findSnap,\n      Ie = r(Te),\n      Fe = r(Ae),\n      Ge = r(Le),\n      Ze = r(Me),\n      Be = r(0);\n    O(function () {\n      Ie.current = Te, Ge.current = Le, Fe.current = Ae, Ze.current = Me, Be.current = Me(J);\n    }, [Me, J, Te, Le, Ae]);\n    var qe = c(function (e) {\n        var n = e.onRest,\n          r = e.config,\n          t = (r = void 0 === r ? {} : r).velocity,\n          o = void 0 === t ? 1 : t,\n          i = C(r, T),\n          a = C(e, M);\n        return new Promise(function (e) {\n          return Se(x({}, a, {\n            config: x({\n              velocity: o\n            }, i, {\n              mass: 1,\n              tension: F,\n              friction: Math.max(G, G + (G - G * o))\n            }),\n            onRest: function onRest() {\n              var r = [].slice.call(arguments);\n              e.apply(void 0, r), null == n || n.apply(void 0, r);\n            }\n          }));\n        });\n      }, [Se]),\n      Ve = d(A, {\n        devTools: !1,\n        actions: {\n          onOpenCancel: c(function () {\n            return null == ve.current ? void 0 : ve.current({\n              type: \"OPEN\"\n            });\n          }, []),\n          onSnapCancel: c(function (e) {\n            return null == ve.current ? void 0 : ve.current({\n              type: \"SNAP\",\n              source: e.snapSource\n            });\n          }, []),\n          onCloseCancel: c(function () {\n            return null == ve.current ? void 0 : ve.current({\n              type: \"CLOSE\"\n            });\n          }, []),\n          onResizeCancel: c(function () {\n            return null == ve.current ? void 0 : ve.current({\n              type: \"RESIZE\",\n              source: Ne.current\n            });\n          }, []),\n          onOpenEnd: c(function () {\n            return null == me.current ? void 0 : me.current({\n              type: \"OPEN\"\n            });\n          }, []),\n          onSnapEnd: c(function (e, n) {\n            return null == me.current ? void 0 : me.current({\n              type: \"SNAP\",\n              source: e.snapSource\n            });\n          }, []),\n          onResizeEnd: c(function () {\n            return null == me.current ? void 0 : me.current({\n              type: \"RESIZE\",\n              source: Ne.current\n            });\n          }, [])\n        },\n        context: {\n          initialState: k\n        },\n        services: {\n          onSnapStart: c(function (e, n) {\n            try {\n              return Promise.resolve(null == fe.current ? void 0 : fe.current({\n                type: \"SNAP\",\n                source: n.payload.source || \"custom\"\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          onOpenStart: c(function () {\n            try {\n              return Promise.resolve(null == fe.current ? void 0 : fe.current({\n                type: \"OPEN\"\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          onCloseStart: c(function () {\n            try {\n              return Promise.resolve(null == fe.current ? void 0 : fe.current({\n                type: \"CLOSE\"\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          onResizeStart: c(function () {\n            try {\n              return Promise.resolve(null == fe.current ? void 0 : fe.current({\n                type: \"RESIZE\",\n                source: Ne.current\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          onSnapEnd: c(function (e, n) {\n            try {\n              return Promise.resolve(null == me.current ? void 0 : me.current({\n                type: \"SNAP\",\n                source: e.snapSource\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          onOpenEnd: c(function () {\n            try {\n              return Promise.resolve(null == me.current ? void 0 : me.current({\n                type: \"OPEN\"\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          onCloseEnd: c(function () {\n            try {\n              return Promise.resolve(null == me.current ? void 0 : me.current({\n                type: \"CLOSE\"\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          onResizeEnd: c(function () {\n            try {\n              return Promise.resolve(null == me.current ? void 0 : me.current({\n                type: \"RESIZE\",\n                source: Ne.current\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, []),\n          renderVisuallyHidden: c(function (e, n) {\n            try {\n              return Promise.resolve(qe({\n                y: Be.current,\n                ready: 0,\n                maxHeight: Ie.current,\n                maxSnap: Ge.current,\n                minSnap: Be.current,\n                immediate: !0\n              })).then(function () {});\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [qe]),\n          activate: c(function (e, n) {\n            try {\n              return de.current = !0, Promise.resolve(Promise.all([De.current.activate(), ze.current.activate(), ke.current.activate()])).then(function () {});\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [ke, ze, De]),\n          deactivate: c(function () {\n            try {\n              return De.current.deactivate(), ze.current.deactivate(), ke.current.deactivate(), de.current = !1, Promise.resolve();\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [ke, ze, De]),\n          openImmediately: c(function () {\n            try {\n              return Oe.current = Be.current, Promise.resolve(qe({\n                y: Be.current,\n                ready: 1,\n                maxHeight: Ie.current,\n                maxSnap: Ge.current,\n                minSnap: Be.current,\n                immediate: !0\n              })).then(function () {});\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [qe]),\n          openSmoothly: c(function () {\n            try {\n              return Promise.resolve(qe({\n                y: 0,\n                ready: 1,\n                maxHeight: Ie.current,\n                maxSnap: Ge.current,\n                minSnap: Be.current,\n                immediate: !0\n              })).then(function () {\n                return Oe.current = Be.current, Promise.resolve(qe({\n                  y: Be.current,\n                  ready: 1,\n                  maxHeight: Ie.current,\n                  maxSnap: Ge.current,\n                  minSnap: Be.current,\n                  immediate: He.current\n                })).then(function () {});\n              });\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [qe, He]),\n          snapSmoothly: c(function (e, n) {\n            try {\n              var r = Ze.current(e.y);\n              return Oe.current = r, z.current = r, Promise.resolve(qe({\n                y: r,\n                ready: 1,\n                maxHeight: Ie.current,\n                maxSnap: Ge.current,\n                minSnap: Fe.current,\n                immediate: He.current,\n                config: {\n                  velocity: e.velocity\n                }\n              })).then(function () {});\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [qe, z, He]),\n          resizeSmoothly: c(function () {\n            try {\n              var e = Ze.current(Oe.current);\n              return Oe.current = e, z.current = e, Promise.resolve(qe({\n                y: e,\n                ready: 1,\n                maxHeight: Ie.current,\n                maxSnap: Ge.current,\n                minSnap: Fe.current,\n                immediate: \"element\" !== Ne.current || He.current\n              })).then(function () {});\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [qe, z, He]),\n          closeSmoothly: c(function (e, n) {\n            try {\n              return qe({\n                minSnap: Oe.current,\n                immediate: !0\n              }), Oe.current = 0, Promise.resolve(qe({\n                y: 0,\n                maxHeight: Ie.current,\n                maxSnap: Ge.current,\n                immediate: He.current\n              })).then(function () {\n                return Promise.resolve(qe({\n                  ready: 0,\n                  immediate: !0\n                })).then(function () {});\n              });\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }, [qe, He])\n        }\n      }),\n      Ke = Ve[0],\n      Je = Ve[1];\n    o(function () {\n      se && Je(H ? \"OPEN\" : \"CLOSE\");\n    }, [H, Je, se]), O(function () {\n      (Te || Le || Ae) && Je(\"RESIZE\");\n    }, [Te, Le, Ae, Je]), o(function () {\n      return function () {\n        De.current.deactivate(), ze.current.deactivate(), ke.current.deactivate();\n      };\n    }, [ke, ze, De]), s(i, function () {\n      return {\n        snapTo: function snapTo(e, n) {\n          var r = void 0 === n ? {} : n,\n            t = r.velocity,\n            o = void 0 === t ? 1 : t,\n            i = r.source,\n            a = void 0 === i ? \"custom\" : i;\n          Je(\"SNAP\", {\n            payload: {\n              y: Ze.current(e),\n              velocity: o,\n              source: a\n            }\n          });\n        },\n        get height() {\n          return Oe.current;\n        }\n      };\n    }, [Je]), o(function () {\n      var e = Pe.current,\n        n = function n(e) {\n          we.current && e.preventDefault();\n        },\n        r = function r(n) {\n          e.scrollTop < 0 && (requestAnimationFrame(function () {\n            e.style.overflow = \"hidden\", e.scrollTop = 0, e.style.removeProperty(\"overflow\");\n          }), n.preventDefault());\n        };\n      return ae && (e.addEventListener(\"scroll\", n), e.addEventListener(\"touchmove\", n), e.addEventListener(\"touchstart\", r)), function () {\n        e.removeEventListener(\"scroll\", n), e.removeEventListener(\"touchmove\", n), e.removeEventListener(\"touchstart\", r);\n      };\n    }, [ae, Pe]);\n    var Qe = y(function (e) {\n      var n = e.args,\n        r = (n = void 0 === n ? [] : n)[0],\n        t = (r = void 0 === r ? {} : r).closeOnTap,\n        o = void 0 !== t && t,\n        i = r.isContentDragging,\n        a = void 0 !== i && i,\n        c = e.cancel,\n        u = e.direction[1],\n        s = e.down,\n        l = e.first,\n        d = e.last,\n        f = e.memo,\n        v = void 0 === f ? ge.y.getValue() : f,\n        m = e.tap,\n        p = e.velocity,\n        y = -1 * e.movement[1];\n      if (!de.current) return c(), v;\n      if (I && o && m) return c(), setTimeout(function () {\n        return I();\n      }, 0), v;\n      if (m) return v;\n      var g = v + y,\n        S = y * p,\n        E = Math.max(Fe.current, Math.min(Ge.current, g + 2 * S));\n      if (!s && I && u > 0 && g + S < Fe.current / 2) return c(), I(), v;\n      var P = s ? I || Fe.current !== Ge.current ? h(g, I ? 0 : Fe.current, Ge.current, .55) : g < Fe.current ? h(g, Fe.current, 2 * Ge.current, .55) : h(g, Fe.current / 2, Ge.current, .55) : E;\n      return ae && a ? (P >= Ge.current && (P = Ge.current), v === Ge.current && Pe.current.scrollTop > 0 && (P = Ge.current), we.current = P < Ge.current) : we.current = !1, l && Je(\"DRAG\"), d ? (Je(\"SNAP\", {\n        payload: {\n          y: P,\n          velocity: p > .05 ? p : 1,\n          source: \"dragging\"\n        }\n      }), v) : (Se({\n        y: P,\n        ready: 1,\n        maxHeight: Ie.current,\n        maxSnap: Ge.current,\n        minSnap: Fe.current,\n        immediate: !0,\n        config: {\n          velocity: p\n        }\n      }), v);\n    }, {\n      filterTaps: !0\n    });\n    if (Number.isNaN(Ge.current)) throw new TypeError(\"maxSnapRef is NaN!!\");\n    if (Number.isNaN(Fe.current)) throw new TypeError(\"minSnapRef is NaN!!\");\n    var Ue = function (e) {\n      var n,\n        r = e.spring,\n        t = v([r.y, r.maxHeight], function (e, n) {\n          return Math.round(N(n - e, 0, 16)) + \"px\";\n        }),\n        o = v([r.y, r.minSnap, r.maxSnap], function (e, n, r) {\n          return N(e, n, r) + \"px\";\n        }),\n        i = v([r.y, r.minSnap, r.maxSnap], function (e, n, r) {\n          return e < n ? n - e + \"px\" : e > r ? r - e + \"px\" : \"0px\";\n        }),\n        a = v([r.y, r.maxSnap], function (e, n) {\n          return e >= n ? Math.ceil(e - n) : 0;\n        }),\n        c = v([r.y, r.minSnap], function (e, n) {\n          if (!n) return 0;\n          var r = Math.max(n / 2 - 45, 0);\n          return N((e - r) * (1 / (Math.min(n / 2 + 45, n) - r) + 0), 0, 1);\n        }),\n        u = v([r.y, r.minSnap], function (e, n) {\n          return n ? N(e / n, 0, 1) : 0;\n        });\n      return (n = {})[\"--rsbs-content-opacity\"] = c, n[\"--rsbs-backdrop-opacity\"] = u, n[\"--rsbs-antigap-scale-y\"] = a, n[\"--rsbs-overlay-translate-y\"] = i, n[\"--rsbs-overlay-rounded\"] = t, n[\"--rsbs-overlay-h\"] = o, n;\n    }({\n      spring: ge\n    }); /*#__PURE__*/\n    return n.createElement(m.div, x({}, ce, {\n      \"data-rsbs-root\": !0,\n      \"data-rsbs-state\": B.find(Ke.matches),\n      \"data-rsbs-is-blocking\": X,\n      \"data-rsbs-is-dismissable\": !!I,\n      \"data-rsbs-has-header\": !!R,\n      \"data-rsbs-has-footer\": !!b,\n      className: P,\n      ref: Ee,\n      style: x({}, Ue, _, {\n        opacity: ge.ready\n      })\n    }), p, X && /*#__PURE__*/n.createElement(\"div\", x({\n      key: \"backdrop\",\n      \"data-rsbs-backdrop\": !0\n    }, Qe({\n      closeOnTap: !0\n    }))), /*#__PURE__*/n.createElement(\"div\", {\n      key: \"overlay\",\n      \"aria-modal\": \"true\",\n      role: \"dialog\",\n      \"data-rsbs-overlay\": !0,\n      tabIndex: -1,\n      ref: Ce,\n      onKeyDown: function onKeyDown(e) {\n        \"Escape\" === e.key && (e.stopPropagation(), I && I());\n      }\n    }, !1 !== R && /*#__PURE__*/n.createElement(\"div\", x({\n      key: \"header\",\n      \"data-rsbs-header\": !0,\n      ref: Re\n    }, Qe()), R), /*#__PURE__*/n.createElement(\"div\", x({\n      key: \"scroll\",\n      \"data-rsbs-scroll\": !0,\n      ref: Pe\n    }, ae ? Qe({\n      isContentDragging: !0\n    }) : {}), /*#__PURE__*/n.createElement(\"div\", {\n      \"data-rsbs-content\": !0,\n      ref: be\n    }, l)), b && /*#__PURE__*/n.createElement(\"div\", x({\n      key: \"footer\",\n      ref: xe,\n      \"data-rsbs-footer\": !0\n    }, Qe()), b)));\n  }),\n  B = [\"closed\", \"opening\", \"open\", \"closing\", \"dragging\", \"snapping\", \"resizing\"];\nfunction q(e) {\n  var n = e.lastSnap;\n  return null != n ? n : Math.min.apply(Math, e.snapPoints);\n}\nfunction V(e) {\n  return e.minHeight;\n}\nvar K = [\"onSpringStart\", \"onSpringEnd\", \"skipInitialTransition\"],\n  J = l(function (t, o) {\n    var i = t.onSpringStart,\n      u = t.onSpringEnd,\n      s = t.skipInitialTransition,\n      l = C(t, K),\n      d = a(!1),\n      f = d[0],\n      v = d[1],\n      m = r(),\n      p = r(null),\n      y = r(s && l.open ? \"OPEN\" : \"CLOSED\");\n    O(function () {\n      if (l.open) return cancelAnimationFrame(m.current), v(!0), function () {\n        y.current = \"CLOSED\";\n      };\n    }, [l.open]);\n    var h = c(function (e) {\n        return Promise.resolve(null == i ? void 0 : i(e)).then(function () {\n          \"OPEN\" === e.type && cancelAnimationFrame(m.current);\n        });\n      }, [i]),\n      g = c(function (e) {\n        return Promise.resolve(null == u ? void 0 : u(e)).then(function () {\n          \"CLOSE\" === e.type && (m.current = requestAnimationFrame(function () {\n            return v(!1);\n          }));\n        });\n      }, [u]);\n    return f ? /*#__PURE__*/n.createElement(e, {\n      \"data-rsbs-portal\": !0\n    }, /*#__PURE__*/n.createElement(Z, x({}, l, {\n      lastSnapRef: p,\n      ref: o,\n      initialState: y.current,\n      onSpringStart: h,\n      onSpringEnd: g\n    }))) : null;\n  });\nexport { J as BottomSheet };","map":null,"metadata":{},"sourceType":"module"}